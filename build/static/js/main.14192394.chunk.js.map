{"version":3,"sources":["serviceWorker.js","index.js","App.js"],"names":["Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","state","address","signature","result","simpleVerification","isValid","bitcoinMessage","verify","e","fallbackVerification","flags","Array","keys","map","i","flag","flagByte","Buffer","alloc","writeInt8","sigBuffer","from","slice","candidateSig","concat","toString","onVerifyClicked","preventDefault","setState","onChange","target","id","value","classes","this","props","className","maxWidth","variant","form","type","fullWidth","label","multiline","rows","color","size","onClick","Component","withStyles","theme","margin","spacing"],"mappings":"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","file":"static/js/main.14192394.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React, { Component } from 'react';\nimport Box from '@material-ui/core/Box';\nimport Container from '@material-ui/core/Container';\nimport Typography from '@material-ui/core/Typography';\nimport TextField from '@material-ui/core/TextField';\nimport Button from '@material-ui/core/Button';\nimport Snackbar from '@material-ui/core/Snackbar';\nimport bitcoinMessage from 'bitcoinjs-message';\nimport './App.css';\nimport { withStyles } from '@material-ui/core/styles';\n\nconst styles = theme => ({\n  form: {\n    '& > *': {\n      margin: theme.spacing(1)\n    },\n  }\n});\n\nclass App extends Component {\n  state = {\n    address: '',\n    message: '',\n    signature: '',\n    result: ''\n  }\n\n  simpleVerification = (message, address, signature) => {\n    let isValid = false;\n    try {\n      isValid = bitcoinMessage.verify(message, address, signature);\n    }catch(e) {\n    }\n    return isValid;\n  }\n\n  fallbackVerification = (message, address, signature) => {\n    let isValid = false;\n    const flags = [...Array(12).keys()].map(i => i + 31);\n    for (let flag of flags) {\n      let flagByte = Buffer.alloc(1);\n      flagByte.writeInt8(flag);\n      let sigBuffer = Buffer.from(signature, 'base64').slice(1);\n      sigBuffer = Buffer.concat([flagByte, sigBuffer]);\n      let candidateSig = sigBuffer.toString('base64');\n      try {\n        isValid = bitcoinMessage.verify(message, address, candidateSig);\n        if (isValid) break;\n      }catch(e) {\n      }\n    }\n    return isValid;\n  }\n\n  onVerifyClicked = e => {\n    e.preventDefault();\n    const {\n      message,\n      address,\n      signature\n    } = this.state;\n\n    let isValid = false;\n    isValid = this.simpleVerification(message, address, signature);\n    if (!isValid) {\n      isValid = this.fallbackVerification(message, address, signature);\n    }\n\n    this.setState({\n      result: isValid ? 'Valid signature' : 'Invalid signature'\n    });\n  };\n\n  onChange = e => {\n    switch(e.target.id) {\n      case 'address':\n        this.setState({address: e.target.value, result: ''});\n        break;\n      case 'signature':\n        this.setState({signature: e.target.value, result: ''});\n        break;\n      case 'message':\n        this.setState({message: e.target.value, result: ''});\n        break;\n    }\n  }\n\n  render() {\n    const { classes } = this.props;\n    return (\n      <Box className=\"App\">\n        <Container maxWidth=\"sm\">\n          <Typography variant=\"h3\">Verify a signed bitcoin message</Typography>\n          <Typography variant=\"body1\">Compatible with the new Segwit Bech32 addresses (beginning with bc1)! This site is the only one on the internet that can do this right now.</Typography>\n        </Container>\n        <Container maxWidth=\"sm\">\n          <form className={classes.form}>\n            <TextField\n              id=\"address\"\n              type=\"text\"\n              variant=\"outlined\"\n              fullWidth\n              label=\"Bitcoin Address\"\n              value={this.state.address}\n              onChange={this.onChange}/>\n            <br></br>\n            <TextField\n              id=\"message\"\n              type=\"text\"\n              variant=\"outlined\"\n              multiline\n              fullWidth\n              rows=\"6\"\n              label=\"Message\"\n              value={this.state.message}\n              onChange={this.onChange}/>\n            <br></br>\n            <TextField\n              id=\"signature\"\n              type=\"text\"\n              variant=\"outlined\"\n              fullWidth\n              label=\"Signature\"\n              value={this.state.signature}\n              onChange={this.onChange}/>\n            <br></br>\n          </form>\n          <Button\n            color=\"primary\"\n            size=\"large\"\n            variant=\"contained\"\n            onClick={this.onVerifyClicked}>\n            Verify\n          </Button>\n          <p id=\"result\">{this.state.result}</p>\n          <Typography variant=\"caption\">\n            ** Works only when the Bech32 address arises from a single public/private key pair with no other conditions. Id it's multisig or timelocked for example, it won't work.\n          </Typography>\n          <br></br>\n          <Typography variant=\"caption\">\n            This website is hosted and maintained by an individual as a charitable endeavour. Please donate to support it!\n          </Typography>\n          <br></br>\n          <Typography variant=\"body1\" variant=\"outlined\">\n            bitcoin address: bc1qkxtzzd3xdv9amc9xhcrpg84z7794m5ju79npf8\n          </Typography>\n          <Typography>\n            legacy: 19fkQrHcM6TNUCfCKTyp9stDpc4F78EStP\n          </Typography>\n        </Container>\n      </Box>\n    );\n  }\n}\n\nexport default withStyles(styles)(App);\n"],"sourceRoot":""}